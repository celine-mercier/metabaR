% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aggregate_pcrs.R
\name{aggregate_pcrs}
\alias{aggregate_pcrs}
\title{Aggregate PCR replicates}
\usage{
aggregate_pcrs(metabarlist, replicates = NULL, FUN = FUN_agg_pcrs_sum)
}
\arguments{
\item{metabarlist}{a \code{metabarlist} object}

\item{replicates}{a vector containing the sample names to which each pcr
replicates belongs and that should be aggregated.
Default is the `sample_id` column from the `pcrs` table.}

\item{FUN}{a function of replicates aggregation.
Default is the sum of reads per MOTUs across replicates.}
}
\value{
A \code{metabarlist} where the table `reads` contains MOTUs abundances aggregated according to \code{FUN} and where number of rows of tables `reads` and `pcrs` is equal to that of table `samples`.
}
\description{
Aggregate PCR replicates in a \code{metabarlist} object.
}
\details{
The function \code{aggregate_pcrs} is typically used at the end of the data filtration process and aims at aggregating reads and the pcr related information at the sample level. The user is free to use its own method of aggregation, but the following are often used and therefore pre-encoded:

#'\itemize{
\item{\code{"FUN_agg_pcrs_sum"}: reads of pcr replicates are summed for each MOTU}
\item{\code{"FUN_agg_pcrs_mean"}: reads of pcr replicates are averaged for each MOTU.
      Results are rounded so that to obtain genuine count data}
\item{\code{"FUN_agg_pcrs_prob"}: the probability of detection is returned for each MOTU.
      This method is often used in studies dealing with ancient DNA or diet.}
}

After aggregation, the information contained in the `pcrs` table is averaged if numeric,
or if not, it is dereplicated if equal across replicates, or concatenated if not.
}
\examples{

data(soil_euk)

## With default function (sum reads across replicates)
soil_euk_ag <- aggregate_pcrs(soil_euk)
summary_metabarlist(soil_euk)
summary_metabarlist(soil_euk_ag)

## With the FUN_agg_prob pre-defined function
soil_euk_ag <- aggregate_pcrs(soil_euk, FUN = FUN_agg_pcrs_prob)
summary_metabarlist(soil_euk)
summary_metabarlist(soil_euk_ag) ## output on reads do not have much sense in this case.

## With a custom function (here equivalent to FUN_agg_pcrs_sum,
## i.e. summing all MOTUs abundance across replicates)
soil_euk_ag <- aggregate_pcrs(soil_euk,
                              FUN = function(metabarlist, replicates){
                                 rowsum(metabarlist$reads, replicates)})

}
\seealso{
\code{\link{aggregate_motus}}, \code{\link{apply}}, \code{\link{aggregate}}
}
\author{
Lucie Zinger, Frédéric Boyer
}
